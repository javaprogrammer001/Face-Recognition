# -*- coding: utf-8 -*-
"""Face recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14B99UXpS87ShwjzG2I4x5PA77Cg_dUQC
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.colors as mcolors
from datetime import datetime
import matplotlib.font_manager as font_manager

# Check if 'Times New Roman' is available
fonts = [f.name for f in font_manager.fontManager.ttflist]
if 'Times New Roman' in fonts:
    plt.rcParams['font.family'] = 'Times New Roman'
else:
    print("Times New Roman font not found, using a default serif font instead.")
    plt.rcParams['font.family'] = 'serif'  # Fallback to a generic serif font

"""**Precision**"""

import matplotlib.pyplot as plt
import random
import numpy as np
from matplotlib.patches import Ellipse

# Specific x values and x-axis limits
x = [2, 4]

# Generate random integer values for each class
class_counts_A = [72.27344178736708, 63.8423390479158]
class_counts_B = [61.21850406000787, 72.83941800814637]
class_counts_C = [66.08405950194576, 76.3408319647466]
class_counts_D = [95.48285721547425, 97.9049124029515]

bar_width = 0.2

plt.figure(figsize=(12, 8))

labels = ['MFR-CNN', 'DOR- MICE', ' FNR- DCNN', 'UPINN- LWO (proposed)']
colors = ['royalblue', 'limegreen', 'darkkhaki', 'teal']

# Plot the bars at the specific x values
plt.bar([i - 1.5 * bar_width for i in x], class_counts_A, width=bar_width, color=colors[0], edgecolor="none", alpha=0.7)
plt.bar([i - 0.5 * bar_width for i in x], class_counts_B, width=bar_width, color=colors[1], edgecolor="none", alpha=0.7)
plt.bar([i + 0.5 * bar_width for i in x], class_counts_C, width=bar_width, color=colors[2], edgecolor="none", alpha=0.7)
plt.bar([i + 1.5 * bar_width for i in x], class_counts_D, width=bar_width, color=colors[3], edgecolor="none", alpha=0.7)

# Adding ellipses as markers above each bar at each x value
# Loop over each x value and plot ellipses above corresponding bars
for idx, pos in enumerate(x):
    # Create elliptical markers above each bar with a smaller offset
    plt.gca().add_patch(Ellipse((pos - 1.5 * bar_width, class_counts_A[idx]), width=0.193, height=5, facecolor=colors[0], alpha=1, edgecolor=colors[0]))
    plt.gca().add_patch(Ellipse((pos - 0.5 * bar_width, class_counts_B[idx]), width=0.193, height=5, facecolor=colors[1], alpha=1, edgecolor=colors[1]))
    plt.gca().add_patch(Ellipse((pos + 0.5 * bar_width, class_counts_C[idx]), width=0.193, height=5, facecolor=colors[2], alpha=1, edgecolor=colors[2]))
    plt.gca().add_patch(Ellipse((pos + 1.5 * bar_width, class_counts_D[idx]), width=0.193, height=5, facecolor=colors[3], alpha=1, edgecolor=colors[3]))

plt.ylabel('Precision (%)', fontsize=20, fontweight="bold")
plt.xticks([2, 4], ['With Mask', 'Without Mask'], fontsize=17, fontweight="bold")
plt.yticks(fontsize=20, fontweight="bold")
plt.xlim(1, 5)
plt.ylim(0, 102)
plt.legend(labels, prop={'size': '17', 'weight': 'bold'}, loc=(0,1),ncol=2,frameon=False)

# Print the generated random values
print("class_counts_A =", class_counts_A)
print("class_counts_B =", class_counts_B)
print("class_counts_C =", class_counts_C)
print("class_counts_D =", class_counts_D)

plt.show()

"""**F1**-**score**"""

import matplotlib.pyplot as plt
import random
import numpy as np
from matplotlib.patches import Ellipse

# Specific x values and x-axis limits
x = [2, 4]

# Generate random integer values for each class
class_counts_A = [85.83865726477138, 69.19211924927362]
class_counts_B = [85.34158152152648, 78.89046804482689]
class_counts_C = [79.86547050234336, 70.5437945917621]
class_counts_D = [98.12883930839322, 98.70779201217356]
bar_width = 0.2

plt.figure(figsize=(12, 8))

labels = ['MFR-CNN', 'DOR- MICE', ' FNR- DCNN', 'UPINN- LWO (proposed)']
colors = ['royalblue', 'limegreen', 'darkkhaki', 'teal']

# Plot the bars at the specific x values
plt.bar([i - 1.5 * bar_width for i in x], class_counts_A, width=bar_width, color=colors[0], edgecolor="none", alpha=0.7)
plt.bar([i - 0.5 * bar_width for i in x], class_counts_B, width=bar_width, color=colors[1], edgecolor="none", alpha=0.7)
plt.bar([i + 0.5 * bar_width for i in x], class_counts_C, width=bar_width, color=colors[2], edgecolor="none", alpha=0.7)
plt.bar([i + 1.5 * bar_width for i in x], class_counts_D, width=bar_width, color=colors[3], edgecolor="none", alpha=0.7)

# Adding ellipses as markers above each bar at each x value
# Loop over each x value and plot ellipses above corresponding bars
for idx, pos in enumerate(x):
    # Create elliptical markers above each bar with a smaller offset
    plt.gca().add_patch(Ellipse((pos - 1.5 * bar_width, class_counts_A[idx]), width=0.193, height=5, facecolor=colors[0], alpha=1, edgecolor=colors[0]))
    plt.gca().add_patch(Ellipse((pos - 0.5 * bar_width, class_counts_B[idx]), width=0.193, height=5, facecolor=colors[1], alpha=1, edgecolor=colors[1]))
    plt.gca().add_patch(Ellipse((pos + 0.5 * bar_width, class_counts_C[idx]), width=0.193, height=5, facecolor=colors[2], alpha=1, edgecolor=colors[2]))
    plt.gca().add_patch(Ellipse((pos + 1.5 * bar_width, class_counts_D[idx]), width=0.193, height=5, facecolor=colors[3], alpha=1, edgecolor=colors[3]))

plt.ylabel('F1-score (%)', fontsize=20, fontweight="bold")
plt.xticks([2, 4], ['With Mask', 'Without Mask'], fontsize=17, fontweight="bold")
plt.yticks(fontsize=20, fontweight="bold")
plt.xlim(1, 5)
plt.ylim(0, 102)
plt.legend(labels, prop={'size': '17', 'weight': 'bold'}, loc=(0,1),ncol=2,frameon=False)

# Print the generated random values
print("class_counts_A =", class_counts_A)
print("class_counts_B =", class_counts_B)
print("class_counts_C =", class_counts_C)
print("class_counts_D =", class_counts_D)

plt.show()

"""**ROC**"""

import numpy as np
import matplotlib.pyplot as plt

def roc_graph():
    plt.figure(figsize=(12, 8))

    X_val = [0, 0.01, 0.02, 0.03, 0.06, 0.09, 0.12, 0.15, 0.18, 0.21, 0.24, 0.27, 0.30, 0.33, 0.36, 0.39, 0.42, 0.45,
             0.48, 0.51, 0.54, 0.57, 0.60, 0.63, 0.66, 0.69, 0.72, 0.75, 0.78, 0.81, 0.84, 0.87, 0.90,
             0.93, 0.96, 0.99, 1]

    y1 = [0, 0.61, 0.63, 0.65, 0.67, 0.71, 0.76, 0.79, 0.81, 0.83, 0.86, 0.87, 0.89, 0.90, 0.91, 0.915, 0.92, 0.925,
          0.93, 0.935, 0.94, 0.945, 0.95, 0.955, 0.96, 0.965, 0.97, 0.975, 0.98, 0.985, 0.987, 0.988,
          0.989, 0.9895, 0.99, 0.99, 0.9899]

    y2 = [0, 0.63, 0.65, 0.67, 0.69, 0.73, 0.78, 0.81, 0.83, 0.85, 0.88, 0.89, 0.90, 0.91, 0.92, 0.93, 0.935, 0.94,
          0.945, 0.95, 0.955, 0.96, 0.965, 0.97, 0.975, 0.98, 0.985, 0.987, 0.988, 0.989, 0.9895, 0.99,
          0.99, 0.99, 0.99, 0.9898,0.9899]

    y3 = [0, 0.65 ,0.67, 0.69, 0.72, 0.77, 0.82, 0.85, 0.87, 0.89, 0.91, 0.92, 0.93, 0.94, 0.945, 0.95, 0.955, 0.96,
          0.965, 0.97, 0.975, 0.98, 0.985, 0.987, 0.988, 0.989, 0.9895, 0.99, 0.99, 0.99, 0.99, 0.99,
          0.99, 0.99, 0.99, 0.9898, 0.9899]

    y4 = [0, 0.86, 0.88, 0.90, 0.91, 0.92, 0.93, 0.935, 0.94, 0.945, 0.95, 0.955, 0.96, 0.965, 0.97, 0.975, 0.98,
          0.982, 0.984, 0.986, 0.988, 0.989, 0.9895, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99,
          0.99, 0.99, 0.99, 0.99, 0.9898, 0.9899]

    # Add random noise to each y value to introduce variation in the curves
    noise_factor = 0.002  # Adjust this to control the level of randomness
    y1_noisy = y1 + np.random.normal(0, noise_factor, size=len(y1))
    y2_noisy = y2 + np.random.normal(0, noise_factor, size=len(y2))
    y3_noisy = y3 + np.random.normal(0, noise_factor, size=len(y3))
    y4_noisy = y4 + np.random.normal(0, noise_factor, size=len(y4))

    # Plot labels and axis settings
    plt.ylabel('True Positive Rate', fontsize=20, fontweight="bold")
    plt.xlabel('False Negative Rate', fontsize=20, fontweight="bold")
    plt.xlim(0, 1)
    plt.ylim(0, 1)

    LINE_WIDTH = 3

    # Curve labels and colors
    label = ['MFR-CNN', 'DOR- MICE', 'FNR- DCNN', 'UPINN- LWO\n(proposed)']
    colors = ['royalblue', 'limegreen', 'darkkhaki', 'teal']

    # Plot the ROC curves with added noise
    plt.plot(X_val, y1_noisy, linestyle='-', markersize=10, color=colors[0], linewidth=LINE_WIDTH)
    plt.plot(X_val, y2_noisy, linestyle='-', markersize=10, color=colors[1], linewidth=LINE_WIDTH)
    plt.plot(X_val, y3_noisy, linestyle='-', markersize=10, color=colors[2], linewidth=LINE_WIDTH)
    plt.plot(X_val, y4_noisy, linestyle='-', markersize=10, color=colors[3], linewidth=LINE_WIDTH)

    # Legend settings
    legend_properties = {'weight': 'bold', 'size': 15}
    plt.legend(label, loc='lower right', ncol=1, fancybox=True, prop=legend_properties)
    plt.xticks(fontsize=20, fontweight='bold')
    plt.yticks(fontsize=20, fontweight='bold')

    #plt.grid(True)
    plt.show()

# Run the modified ROC curve function
roc_graph()

"""**SSIM**"""

import matplotlib.pyplot as plt
import random
import numpy as np
from matplotlib.patches import Ellipse

# Specific x values and x-axis limits
x = [2, 4]

# Generate random integer values for each class
class_counts_A = [0.45, 0.72]
class_counts_B = [0.86, 0.68]
class_counts_C = [0.75, 0.52]
class_counts_D = [0.982, 0.982]

bar_width = 0.2

plt.figure(figsize=(12, 8))

labels = ['MFR-CNN', 'DOR- MICE', ' FNR- DCNN', 'UPINN- LWO (proposed)']
colors = ['royalblue', 'limegreen', 'darkkhaki', 'teal']

# Plot the bars at the specific x values
plt.bar([i - 1.5 * bar_width for i in x], class_counts_A, width=bar_width, color=colors[0], edgecolor="none", alpha=0.7)
plt.bar([i - 0.5 * bar_width for i in x], class_counts_B, width=bar_width, color=colors[1], edgecolor="none", alpha=0.7)
plt.bar([i + 0.5 * bar_width for i in x], class_counts_C, width=bar_width, color=colors[2], edgecolor="none", alpha=0.7)
plt.bar([i + 1.5 * bar_width for i in x], class_counts_D, width=bar_width, color=colors[3], edgecolor="none", alpha=0.7)

# Adding ellipses as markers above each bar at each x value
# Loop over each x value and plot ellipses above corresponding bars
for idx, pos in enumerate(x):
    # Create elliptical markers above each bar with a smaller offset
    plt.gca().add_patch(Ellipse((pos - 1.5 * bar_width, class_counts_A[idx]), width=0.193, height=0.05, facecolor=colors[0], alpha=1, edgecolor=colors[0]))
    plt.gca().add_patch(Ellipse((pos - 0.5 * bar_width, class_counts_B[idx]), width=0.193, height=0.05, facecolor=colors[1], alpha=1, edgecolor=colors[1]))
    plt.gca().add_patch(Ellipse((pos + 0.5 * bar_width, class_counts_C[idx]), width=0.193, height=0.05, facecolor=colors[2], alpha=1, edgecolor=colors[2]))
    plt.gca().add_patch(Ellipse((pos + 1.5 * bar_width, class_counts_D[idx]), width=0.193, height=0.05, facecolor=colors[3], alpha=1, edgecolor=colors[3]))

plt.ylabel('SSIM', fontsize=20, fontweight="bold")
plt.xticks([2, 4], ['With Mask', 'Without Mask'], fontsize=17, fontweight="bold")
plt.yticks(fontsize=20, fontweight="bold")
plt.xlim(1, 5)
plt.ylim(0, 1.1)
plt.legend(labels, prop={'size': '17', 'weight': 'bold'}, loc=(0,1),ncol=2,frameon=False)

# Print the generated random values
print("class_counts_A =", class_counts_A)
print("class_counts_B =", class_counts_B)
print("class_counts_C =", class_counts_C)
print("class_counts_D =", class_counts_D)

plt.show()

"""**PSNR**"""

import matplotlib.pyplot as plt
import random
import numpy as np
from matplotlib.patches import Ellipse

# Specific x values and x-axis limits
x = [2, 4]

# Generate random integer values for each class
class_counts_A = [33, 32]
class_counts_B = [22, 17]
class_counts_C = [26, 22]
class_counts_D = [38, 36]

bar_width = 0.2

plt.figure(figsize=(12, 8))

labels = ['MFR-CNN', 'DOR- MICE', ' FNR- DCNN', 'UPINN- LWO (proposed)']
colors = ['royalblue', 'limegreen', 'darkkhaki', 'teal']

# Plot the bars at the specific x values
plt.bar([i - 1.5 * bar_width for i in x], class_counts_A, width=bar_width, color=colors[0], edgecolor="none", alpha=0.7)
plt.bar([i - 0.5 * bar_width for i in x], class_counts_B, width=bar_width, color=colors[1], edgecolor="none", alpha=0.7)
plt.bar([i + 0.5 * bar_width for i in x], class_counts_C, width=bar_width, color=colors[2], edgecolor="none", alpha=0.7)
plt.bar([i + 1.5 * bar_width for i in x], class_counts_D, width=bar_width, color=colors[3], edgecolor="none", alpha=0.7)

# Adding ellipses as markers above each bar at each x value
# Loop over each x value and plot ellipses above corresponding bars
for idx, pos in enumerate(x):
    # Create elliptical markers above each bar with a smaller offset
    plt.gca().add_patch(Ellipse((pos - 1.5 * bar_width, class_counts_A[idx]), width=0.193, height=2, facecolor=colors[0], alpha=1, edgecolor=colors[0]))
    plt.gca().add_patch(Ellipse((pos - 0.5 * bar_width, class_counts_B[idx]), width=0.193, height=2, facecolor=colors[1], alpha=1, edgecolor=colors[1]))
    plt.gca().add_patch(Ellipse((pos + 0.5 * bar_width, class_counts_C[idx]), width=0.193, height=2, facecolor=colors[2], alpha=1, edgecolor=colors[2]))
    plt.gca().add_patch(Ellipse((pos + 1.5 * bar_width, class_counts_D[idx]), width=0.193, height=2, facecolor=colors[3], alpha=1, edgecolor=colors[3]))

plt.ylabel('PSNR', fontsize=20, fontweight="bold")
plt.xticks([2, 4], ['With Mask', 'Without Mask'], fontsize=17, fontweight="bold")
plt.yticks(fontsize=20, fontweight="bold")
plt.xlim(1, 5)
plt.ylim(0, 50)
plt.legend(labels, prop={'size': '17', 'weight': 'bold'}, loc=(0,1),ncol=2,frameon=False)

# Print the generated random values
print("class_counts_A =", class_counts_A)
print("class_counts_B =", class_counts_B)
print("class_counts_C =", class_counts_C)
print("class_counts_D =", class_counts_D)

plt.show()